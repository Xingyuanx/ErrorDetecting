## 目标

* 基于现有需求文档与数据库建表脚本，生成一份从零开始的 PostgreSQL 部署步骤教程文件（Markdown）。

* 生成与项目技术栈匹配的后端初始代码（FastAPI + SQLAlchemy + asyncpg），覆盖基础连通与核心模块最小可用接口。

## 参考依据

* 需求规格说明书：`doc/project/需求规格说明书.md`

* 建表脚本：`doc/project/数据库建表脚本_postgres.sql`

* 数据库设计与ER说明：`doc/project/数据库设计文档.md`、`doc/project/ER图设计说明.md`

## 交付物

* 新增文档：`doc/project/数据库部署步骤教程.md`

* 新增代码目录：`backend/`

  * `backend/requirements.txt`

  * `backend/app/main.py`

  * `backend/app/config.py`

  * `backend/app/db.py`

  * `backend/app/models/*.py`（核心表模型：clusters、nodes、system\_logs、fault\_records、exec\_logs 等）

  * `backend/app/schemas/*.py`（Pydantic 模型）

  * `backend/app/routers/*.py`（clusters、faults、logs、health）

## 数据库部署教程大纲

* 环境要求与准备

  * PostgreSQL 14+，Windows 环境（PowerShell），或 Docker Desktop

  * 建表脚本路径与说明（不包含 CREATE DATABASE）

* 安装 PostgreSQL（两种方式）

  * 安装器方式：下载安装、设置超级用户、添加 PATH

  * Docker 方式：`docker run -d --name pg -e POSTGRES_PASSWORD=... -p 5432:5432 postgres:14`

* 初始化数据库与用户

  * 创建数据库：`CREATE DATABASE hadoop_fault_db WITH ENCODING 'UTF8';`

  * 可选：创建业务用户与授权

  * 本地认证配置（`pg_hba.conf` 的 `host all all 127.0.0.1/32 md5` 提示）

* 执行建表脚本

  * Windows：`psql -U postgres -h localhost -d hadoop_fault_db -f doc/project/数据库建表脚本_postgres.sql`

  * Docker：`docker cp` + 容器内 `psql -f` 执行

* 验证与自检

  * 表/索引/约束检查示例查询（如 `\dt`、`\di`、`\d+ fault_records`）

  * 运行脚本内置的示例数据并验证返回提示语句

* 备份与恢复

  * 备份：`pg_dump -U postgres -d hadoop_fault_db > backup.sql`

  * 恢复：`psql -U postgres -d hadoop_fault_db -f backup.sql`

* 连接字符串与安全建议

  * DSN 示例：`postgresql://postgres:<pwd>@localhost:5432/hadoop_fault_db`

  * 禁止明文密钥入库、最小权限、定期备份演练

## 后端初始代码计划

* 依赖管理：`requirements.txt`

  * `fastapi`, `uvicorn[standard]`, `SQLAlchemy>=2`, `asyncpg`, `pydantic`, `python-dotenv`

* 配置模块：`app/config.py`

  * 加载环境变量（数据库 DSN、服务端口、日志级别）

* 数据库模块：`app/db.py`

  * 创建 `AsyncEngine` 与 `async_sessionmaker`，封装获取/关闭会话函数（含函数级注释/Docstring）

* SQLAlchemy 模型：`app/models/*.py`

  * 映射核心表（clusters、nodes、system\_logs、fault\_records、exec\_logs、roles、permissions、user\_role\_mapping、user\_cluster\_mapping、app\_configurations、audit\_logs）

  * 类型对齐：`JSONB`→`postgresql.JSONB`、`INET`→`postgresql.INET`、时间→`TIMESTAMP(timezone=True)`

* Pydantic 模型：`app/schemas/*.py`

  * 输入/输出模型（ClusterCreate/ClusterRead、FaultCreate/FaultRead、LogQuery）

* 路由模块：`app/routers/*.py`

  * `health.py`：健康检查（DB连通探测）

  * `clusters.py`：`GET /api/v1/clusters`、`POST /api/v1/clusters`

  * `faults.py`：`GET /api/v1/faults`、`POST /api/v1/faults`

  * `logs.py`：`GET /api/v1/logs`（分页/过滤）

* 应用入口：`app/main.py`

  * 注册路由、CORS（允许前端域名）、异常处理器、版本前缀 `/api/v1`

* 运行说明

  * 创建虚拟环境并安装：`python -m venv venv & venv\Scripts\activate & pip install -r requirements.txt`

  * 启动：`uvicorn app.main:app --reload`

  * 环境配置：`.env` 中设置 `DATABASE_URL=postgresql+asyncpg://postgres:<pwd>@localhost:5432/hadoop_fault_db`

## 代码片段示例（将用于实际生成）

* `app/db.py`

```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

DATABASE_URL = "postgresql+asyncpg://postgres:password@localhost:5432/hadoop_fault_db"
engine = create_async_engine(DATABASE_URL, echo=False, pool_pre_ping=True)
SessionLocal = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

async def get_db() -> AsyncSession:
    """获取一个异步数据库会话，用于依赖注入。"""
    async with SessionLocal() as session:
        yield session
```

* `app/main.py`

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.routers import health, clusters, faults, logs

app = FastAPI(title="Hadoop Fault Detecting API", version="v1")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])
app.include_router(health.router, prefix="/api/v1")
app.include_router(clusters.router, prefix="/api/v1")
app.include_router(faults.router, prefix="/api/v1")
app.include_router(logs.router, prefix="/api/v1")
```

* `app/routers/health.py`

```python
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.db import get_db

router = APIRouter()

@router.get("/health")
async def health_check(db: AsyncSession = Depends(get_db)):
    """健康检查：测试数据库连通性。"""
    await db.execute("SELECT 1")
    return {"status": "ok"}
```

* `app/routers/clusters.py`（示例）

```python
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.db import get_db
from app.models.clusters import Cluster

router = APIRouter()

@router.get("/clusters")
async def list_clusters(db: AsyncSession = Depends(get_db)):
    """查询集群列表。"""
    result = await db.execute(select(Cluster).limit(100))
    rows = result.scalars().all()
    return {"total": len(rows), "list": [c.to_dict() for c in rows]}
```

## 验证与后续工作

* 我将按上述结构生成教程文件与后端初始代码，并在本地运行基本连通（`/health`、`/clusters`）进行自检。

* 后续可按 SRS 模块逐步扩展接口与实体映射，增加 WebSocket、审计与权限模块。

